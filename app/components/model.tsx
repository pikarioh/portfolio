/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three';
import React, { use, useRef } from 'react';
import { MeshReflectorMaterial, MeshTransmissionMaterial, useGLTF } from '@react-three/drei';
import { GLTF } from 'three-stdlib';
import { useFrame, useThree } from '@react-three/fiber';
import { ior, min, roughness, step, transmission } from 'three/tsl';
import { useControls } from 'leva';

type GLTFResult = GLTF & {
  nodes: {
    underscore: THREE.Mesh;
    l2: THREE.Mesh;
    l1: THREE.Mesh;
    e: THREE.Mesh;
    h: THREE.Mesh;
    o: THREE.Mesh;
  };
  materials: {
    ['Material.001']: THREE.MeshStandardMaterial;
  };
};

const amplitude = 0.05;
const constant = 0.2;

export function Model(props: React.ComponentProps<'group'>) {
  const [radian, setRadian] = React.useState(0);
  const [frame, setFrame] = React.useState(0);
  const { nodes, materials } = useGLTF('/portfolio_title.glb') as unknown as GLTFResult;
  const { viewport } = useThree();

  const [toggle, setToggle] = React.useState(false);

  React.useEffect(() => {
    const interval = setInterval(() => setToggle((prev) => !prev), 1000);
    return () => clearInterval(interval);
  }, []);

  const meshRefs = [
    useRef<THREE.Mesh>(null), // l1Ref
    useRef<THREE.Mesh>(null), // l2Ref
    useRef<THREE.Mesh>(null), // eRef
    useRef<THREE.Mesh>(null), // hRef
    useRef<THREE.Mesh>(null), // oRef
    useRef<THREE.Mesh>(null), // underscoreRef
  ];
  const [l1Ref, l2Ref, eRef, hRef, oRef, underscoreRef] = meshRefs;

  const materialProps = {
    thickness: 0.5,
    roughness: 0.1,
    transmission: 0.8,
    ior: 1.5,
    chromaticAberration: 0.1,
    backside: true,
  };

  useFrame(() => {
    if (radian > Math.PI * 2) {
      setRadian(0);
    } else {
      setRadian((prev) => prev + 0.01);
    }

    if (hRef.current) {
      hRef.current.position.y = Math.sin(radian + 1) * amplitude + constant;
    }
    if (eRef.current) {
      eRef.current.position.y = Math.sin(radian + Math.PI) * amplitude + constant;
    }
    if (l1Ref.current) {
      l1Ref.current.position.y = Math.sin(radian) * amplitude + constant;
    }
    if (l2Ref.current) {
      l2Ref.current.position.y = Math.sin(radian + Math.PI) * amplitude + constant;
    }
    if (oRef.current) {
      oRef.current.position.y = Math.sin(radian + 2) * amplitude + constant;
    }
    if (underscoreRef.current) {
      underscoreRef.current.position.y = (Math.sin(radian + 3) * amplitude) / 2 - 1;
    }
  });

  return (
    <group {...props} dispose={null} scale={viewport.width / 14}>
      <mesh position={[0, -1.5, 0]} rotation={[-Math.PI / 2, 0, 0]}>
        <planeGeometry args={[100, 200]} />
        <MeshReflectorMaterial
          blur={[200, 200]}
          resolution={1024}
          mixBlur={1}
          mixStrength={5}
          depthScale={1}
          minDepthThreshold={0.85}
          color="#dff2fe"
          metalness={0.1}
          roughness={0.5}
        />
      </mesh>
      <mesh
        ref={underscoreRef}
        onClick={() => setFrame((prev) => prev + 1)}
        castShadow
        receiveShadow
        geometry={nodes.underscore.geometry}
        material={materials['Material.001']}
        position={[3.958, -0.925, 0]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={4.55}
      >
        <MeshTransmissionMaterial
          color="#0078c2"
          emissive={toggle ? '#000000' : '#2ac9fe'}
          emissiveIntensity={1.5}
          thickness={0.1}
          metalness={0.5}
          roughness={0.5}
        />
      </mesh>
      <mesh
        ref={l2Ref}
        castShadow
        receiveShadow
        geometry={nodes.l2.geometry}
        material={materials['Material.001']}
        position={[0.712, 0.22, 0]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={4.55}
      >
        <MeshTransmissionMaterial {...materialProps} />
      </mesh>
      <mesh
        ref={l1Ref}
        castShadow
        receiveShadow
        geometry={nodes.l1.geometry}
        material={materials['Material.001']}
        position={[-0.893, 0.22, 0]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={4.55}
      >
        <MeshTransmissionMaterial {...materialProps} />
      </mesh>
      <mesh
        ref={eRef}
        castShadow
        receiveShadow
        geometry={nodes.e.geometry}
        material={materials['Material.001']}
        position={[-2.491, 0.115, 0]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={4.55}
      >
        <MeshTransmissionMaterial {...materialProps} />
      </mesh>
      <mesh
        ref={hRef}
        castShadow
        receiveShadow
        geometry={nodes.h.geometry}
        material={materials['Material.001']}
        position={[-4.154, 0.24, 0]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={4.55}
      >
        <MeshTransmissionMaterial {...materialProps} />
      </mesh>
      <mesh
        ref={oRef}
        castShadow
        receiveShadow
        geometry={nodes.o.geometry}
        material={materials['Material.001']}
        position={[2.353, 0.111, 0]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={4.55}
      >
        <MeshTransmissionMaterial {...materialProps} />
      </mesh>
    </group>
  );
}

useGLTF.preload('/portfolio_title.glb');
